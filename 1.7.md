> 来源：[1.7 递归函数](http://composingprograms.com/pages/17-recursive-functions.html)

## 1.7 递归函数

如果函数体直接或者间接函数本身，那么这个函数是递归的

我们将从一个示例问题开始：编写一个对自然数的数字求和的函数。在设计递归函数时，我们寻找可以将问题分解为更简单问题的方法。在这种情况下，运算符 `%`和`//`可用于将数字分成两部分：它的最后一位和除最后一位之外的所有数字

```python
>>> 18117  %  10 
7 
>>> 18117  //  10 
1811
```

18117 的数字之和是`1+8+1+1+7 = 18`。，我们可以将这个和分成最后一位数字 7 和除最后一位数字之外的所有数字的总和`1+8+1+1 = 11`。这种分离为我们提供了一个算法：将数字`n`的数字相加，将其最后一位数字`n % 10 `添加到`n // 10`的数字总和中。有一种特殊情况：如果一个数只有一位数，那么它的数位之和就是它本身。该算法可以递归函数实现。

```python
>>> def sum_digits(n):
        """Return the sum of the digits of positive integer n."""
        if n < 10:
            return n
        else:
            all_but_last, last = n // 10, n % 10
            return sum_digits(all_but_last) + last
```

`sum_digits` 的这个定义既完整又正确，即使 `sum_digits` 函数是在其自身内部调用的。 将数字的数字相加的问题分为两个步骤：将除最后一位之外的所有数字相加得到num，然后将最后一位与num相加。 这两个步骤都比原来的问题简单。 该函数是递归的，因为第一步是与原始问题相同的问题。 也就是说，`sum_digits` 正是我们实现 `sum_digits` 所需的函数。

```python
>>> sum_digits(9)
9
>>> sum_digits(18117)
18
>>> sum_digits(9437184)
36
>>> sum_digits(11408855402054064613470328848384)
126
```

我们可以使用我们的计算环境模型准确地理解这个递归函数是如何调用的。 不需要新规则。

![1.7.1](img\1.7.1.png)

执行 `def` 语句时，名称` sum_digits` 绑定到一个新函数上。 然后，在用738 调用 `sum_digits`：

1. 为 `sum_digits` 创建一个 n 绑定到 738 的局部帧，并在以该帧开始的环境中执行` sum_digits` 的函数体。
2. 由于738不小于10，执行第4行赋值语句，将738拆分为73和8。
3. 在下面的 return 语句中，用73调用`sum_digits` ，即当前环境中 all_but_last 的值。
4. `sum_digits` 的另一个局部帧被创建，这次 n 绑定到 73。 `sum_digits`的函数体再次在以该帧开始的新环境中执行。
5. 由于73也不小于10，73被拆分为7和3，并用7调用`sum_digits`，`all_but_last`的值在这一帧中求值。
6. 为 `sum_digits` 创建了第三个局部帧，其中 n 绑定到 7。
7. 在以该帧开始的环境中，确实 n < 10，因此返回 7。
8. 在第二个局部帧中，这个返回值 7 与最后的值 3 相加，返回 10。
9. 在第一个局部帧中，这个返回值 10 与最后的值 8 相加，返回 18。

尽管具有循环特征，但此递归函数正确的被调用，因为它被调用了两次，但每次使用不同的参数。 此外，第二个程序是一个比第一个更简单的数字求和问题的实例。 查看计算` sum_digits(18117)` 生成的环境图。

这个例子还说明了具有简单实体的函数如何通过使用递归来演化复杂的计算过程。

## 1.7.1 剖析递归函数

在许多递归函数的主体中可以找到一个常见的模式。函数体从基本情况开始，它是一个条件语句，用来处理最简单的情况。在 `sum_digits` 这个例子中，基本情况：参数是1位数的，我们只需返回该参数。一些递归函数有多个基本情况。

基本情况之后是一个或多个递归调用。 递归调用总是有一个特点：它们简化了原来的问题。 递归函数通过逐步简化问题来表达计算。 例如，对 数字7求和比对 数字73求和更简单，而 数字73求和又比对数字738求和更简单。对于随后的每个调用，它的工作量更少。

递归调用通过逐步简化问题来表达计算。与我们在过去使用过的迭代方式相比，它们通常以不同方式来解决问题。考虑用于计算`n`的阶乘的函数`fact`，其中`fact(4)`计算了`4! = 4·3·2·1 = 24`。

使用`while`语句实现会通过将每个小于或等于`n`的正数相乘来求出结果。

```python
>>> def fact_iter(n):
        total, k = 1, 1
        while k <= n:
            total, k = total * k, k + 1
        return total
>>> fact_iter(4)
24
```

另一方面，阶乘的递归实现可以以`fact(n-1)`（一个更简单的问题）来表示`fact(n)`。递归的基本情况是问题的最简单的情况：`fact(1)`是`1`。

![1.7.2](img\1.7.2.png)

这两个阶乘函数在概念上有所不同。 迭代函数通过在每一项中连续相乘来构造从基本情况  到最终情况的结果。 另一方面，递归函数直接从最后一项 n 和更简单问题的结果 `fact(n-1)` 构造结果。

递归函数`fact`通过不断在当前情况上用更简单的问题调用自己，直到满足基本情况并从基本情况开始构建。每次调用的结果取决于下一次调用。 递归的结束从计算基本情况的return表达式开始。 

函数的正确性可以通过阶乘函数的标准数学定义来验证。

```
(n − 1)! = (n − 1)·(n − 2)· ... · 1
n！ = n·(n − 1)·(n − 2)· ... · 1
n! = n·(n − 1)!  
```

虽然我们可以使用我们的计算模型展开递归，但将递归调用视为函数抽象通常更清晰。也就是说，我们不应该关心`fact(n-1)`如何在`fact`的函数体中如何实现；我们只需要相信它计算了`n-1`的阶乘。将递归调用看做函数抽象叫做递归的“信仰飞跃”。我们根据函数本身定义函数，但只需相信在验证函数的正确性时，更简单的情况会正确工作。这个例子中我们相信，`fact(n-1)`会正确计算`(n-1)!`；我们只需要检查，如果满足假设`n!`是否正确计算。这样，递归函数正确性的验证就变成了一种归纳证明。

函数`fact_iter`和`fact`也不一样，因为前者必须引入两个额外的名称，`total`和`k`，它们在递归实现中并不需要。通常，迭代函数必须维护一些局部状态，它们会在计算过程中改变。在任何迭代的时间点上，该状态展示已完成工作的结果和剩余工作量。例如，当`k`为`3`且`total`为`2`时，就还剩下两个项`3`和`4`没有处理。另一方面，`fact`的特点是它的单一参数 n。计算的状态完全包含在环境的结构中，它的返回值起到`total`的作用，并且在不同的帧中将`n`绑定到不同的值上，而不是显式跟踪`k`。

递归函数利用计算函数调用的规则将名称绑定到值，通常可以避免在迭代期间正确分配本地名称的麻烦。 因此，递归函数可以更容易地正确定义。 然而，要弄懂调用递归函数的这个计算过程，需要一些练习



## 1.7.2   相互递归

当递归过程被划分为两个相互调用的函数时，我们称这两个函数是相互递归的。 例如，考虑以下非负整数的偶数和奇数定义：

- 一个数是偶数，则它比奇数多一
- 一个数是奇数，则它比偶数多一
- 0 是偶数

使用这个定义，我们可以用相互递归来确定一个数是偶数还是奇数：

```python
def is_even(n):
	if n == 0:
	     return True
	 else:
	     return is_odd(n-1)
	
def is_odd(n):
	if n == 0:
	     return False
	else:
	     return is_even(n-1)
	
result = is_even(4)
```

通过打破两个函数之间的抽象边界，可以将互递归函数变成单个递归函数。 在这个例子中，`is_odd` 的函数体可以合并到` is_even` 的函数体中，确保在 `is_odd` 函数体中用 `n-1` 替换 `n` 以反映传递给它的参数：

```python
>>> def is_even(n):
        if n == 0:
            return True
        else:
            if (n-1) == 0:
                return False
            else:
                return is_even((n-1)-1)
```

因此，相互递归并不比简单递归更神秘或更强大，它提供了一种在复杂递归程序中维护抽象的机制



## 1.7.3  打印递归函数

通常可以使用调用`print`来可视化调用递归函数的计算过程。 例如，我们将实现函数` cascade`

```python
>>> def cascade(n):
        """Print a cascade of prefixes of n."""
        if n < 10:
            print(n)
        else:
            print(n)
            cascade(n//10)
            print(n)
>>> cascade(2013)
2013
201
20
2
20
201
2013
```

在此递归函数中，基本情况是n<10, 否则，将在两次调用`print`之间进行递归调用。

在递归调用之前表达基本情况并不是硬性要求,我们可以简化这个函数

```python
>>> def cascade(n):
        """Print a cascade of prefixes of n."""
        print(n)
        if n >= 10:
            cascade(n//10)
            print(n)
```

作为相互递归的另一个例子，考虑一个两人游戏，桌子上最开始有 n 个鹅卵石。 玩家轮流从桌子上取出一颗或两颗鹅卵石，取出最后一颗鹅卵石的玩家获胜。 假设 Alice 和 Bob 玩这个游戏，每个人都使用一个简单的策略：

- Alice总是移走一颗鹅卵石
- 如果桌子上有偶数个鹅卵石，Bob 取出两颗鹅卵石，否则取出一颗
- 假设从爱丽丝开始，谁赢得了比赛？

这个问题就是将每个策略封装在它自己的函数中。 这允许我们在不影响另一个策略的情况下修改一种策略，保持两者之间的抽象障碍。 为了结合游戏的回合性质，这两个函数在每回合结束时相互调用。

```python
>>> def play_alice(n):
        if n == 0:
            print("Bob wins!")
        else:
            play_bob(n-1)
>>> def play_bob(n):
        if n == 0:
            print("Alice wins!")
        elif is_even(n):
            play_alice(n-2)
        else:
            play_alice(n-1)
>>> play_alice(20)
Bob wins
```

在 `play_bob` 中，我们看到多个递归调用出现在函数体中。 然而，在这个例子中，每次调用 `play_bob` 最多调用一次 `play_alice`。 在1.7.4中，我们将考虑当单个函数调用进行多个递归调用时会发生什么？



## 1.7.3 树递归

另一种常见的计算模式称为树递归，其中一个函数多次调用自身。 例如，考虑计算斐波那契数列，其中每个数都是前两个数之和。

```python
>>> def fib(n):
        if n == 1:
            return 0
        if n == 2:
            return 1
        return fib(n-2) + fib(n-1)
>>> fib(6)
5
```

相对于我们之前的尝试，这个递归定义非常有吸引力：它完全反映了我们熟悉的斐波那契数的定义。树递归的每个调用分支会变成多个较小的调用，就像树的分支从树干延伸时变得更小但数量更多。

我们已经能够定义一个函数来计算斐波那契数，而无需树递归。 事实上，我们之前的方案效率更高，这是本文后面讨论的主题。 接下来，我们考虑一个问题，对于该问题，树递归解决方案比任何迭代方案都简单得多。

### 1.7.5  Example: Partitions

用m来划分正整数 n，计算有多少种划分的方法，我们认为任意个小于或等于m的数相加等于n,则这是一种划分的方法，不能重复。     例如，用m=4来划分n=6，有9种分法：

1. `6 = 2 + 4`
2. `6 = 1 + 1 + 4`
3. `6 = 3 + 3`
4. `6 = 1 + 2 + 3`
5. `6 = 1 + 1 + 1 + 3`
6. `6 = 2 + 2 + 2`
7. `6 = 1 + 1 + 2 + 2`
8. `6 = 1 + 1 + 1 + 1 + 2`
9. `6 = 1 + 1 + 1 + 1 + 1 + 1`

定义一个函数 `count_partitions(n, m)`，它使用 m 来划 n ，并返回不同的划分方法数。我们可以使用树递归来轻易的实现这个函数，基于以下公式：

用 m 划分 n 的方法数 == 用 m 划分 n-m 的方法数+用 m-1 划分 n 的方法数。

要了解为什么这是真的，所有可以划分 n 的方法都可以分为两组：至少包括一个 m 的方法和不包括的 m 的方法 。而且，第一组中的每个方法都是n先减去m，在n-m划分。例如; 2+4, 6-4=2， 在对2用m划分。

因此，我们可以将用 m 划分 n 的问题不断地简化为两个更简单的问题：（1）对新的n划分（n=n-m)（2）用新的m来划分 (m= m-1) 。

为了实现这个树递归，我们需要指定基本情况：

- 有一种划分 0 的方法：不包含任何部分。
- 有 0 种划分负 数n 的方法。
- 有 0 种方法可以使用小于或等于0的数来划分任何大于 0 的数 n。

```python
>>> def count_partitions(n, m):
        """Count the ways to partition n using parts up to m."""
        if n == 0:
            return 1
        elif n < 0:
            return 0
        elif m == 0:
            return 0
        else:
            return count_partitions(n-m, m) + count_partitions(n, m-1)
>>> count_partitions(6, 4)
9
>>> count_partitions(5, 5)
7
>>> count_partitions(10, 10)
42
>>> count_partitions(15, 15)
176
>>> count_partitions(20, 20)
627
```

我们可以将树递归函数视为探索不同的可能性

在没有递归的情况下实现这个函数会涉及更多。鼓励有兴趣的读者尝试。