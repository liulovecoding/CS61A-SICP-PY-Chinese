# 2.3 序列

> 来源：[2.3   Sequences](http://composingprograms.com/pages/23-sequences.html)

序列是值的有序集合。序列是计算机科学中强大的基本抽象。序列不是特定内置类型或抽象数据表示的实例，而是在几种不同类型的数据之间共享的行为集合。也就是说，序列有很多种，但它们都有共同的行为。特别是：

> 字符串，列表，元组，range都是序列的一种

**长度。**序列拥有有限的长度。空序列的长度为 0。

**元素选择。**序列的每个元素都拥有相应的非负整数作为下标，它小于序列长度，第一个元素从 0 开始。



## 2.3.1序列介绍



### Lists

列表具有大量内置行为，以及表达这些行为的特定语法。 我们已经看到了列表字面值，其计算结果为列表实例，以及计算结果为列表中的值的元素选择表达式。

```python
>>> digits = [1, 8, 2, 8] #创建一个包含四个元素的列表      
>>> len(digits)
4
```

**列表的元素可以是任何类型的值**

**列表的元素是可修改的**(修改的是引用变量的值)

```python
>>> pairs = [[10, 20], [30, 40],(2,3)]
>>> for x,y in digits:
        print(x,y)
10,20
30,40
2,3
>>> pairs[0][0]=1,paris[2]=(3,3)
>>>pairs
[[1,20],[20,40],(3,3)]
>>> list(zip([1, 2, 5, 3], [9, 2, 6, 3, 10]))
[(1, 9), (2, 2), (5, 6), (3, 3)]
>>> list(zip([1, 4, 7,	10], [2, 5, 8, 11],	[3, 6, 9, 12, 15]))
[(1, 2, 3), (4, 5, 6),	(7, 8, 9), (10, 11,	12)]

```

**通过列表创建新列表**

```python
list1=[1,2,3,4]
list3=list2[:]
list3=list(list1)
list2=list1 #指向同一个列表对象
#可以用id和is判断
```

**is :不要用于字符串和数值**，除非你有明确地理由否则别用

```python
if list1 is None:#用处1
    pass
if  type(list1) is type(list2):#用处2,类型比较
    pass
```



```python
list1 = [1,2,3]#创建一个对象
list2 = [1,2,3]#又创建一个
>>>id(list1)
2499849049216
>>>id(list2)
2499849167616
>>>identical = list1 is list2  #list1和list2指向的是同个对象时则返回True
False
>>>are_equal = list1 == list2 #llist1 和list2所指向地对象地内容相等时则返回True
True
# 相同的对象总是具有相同的值
```

列表推导式：许多序列处理操作可以通过为序列中的每个元素计算一个固定表达式并收集结果序列中的结果值来表示。 列表推导式是针对列表的一种序列推导式

```python
>>> odds = [1, 3, 5, 7, 9]
>>> [x+1 for x in odds]
[2, 4, 6, 8, 10]
```

上面的关键字for不是 for 语句的一部分，而是列表推导式的一部分，因为它包含在方括号中。 子表达式 x+1 被计算为 x 依次绑定到odds 的每个元素，并将结果值收集到一个列表中。

另一种常见的序列处理操作是选择满足某些条件的值的集合， 列表推导式也可以表达这种模式，例如选择能够被25整除的元素。

```python
>>> [x for x in odds if 25 % x == 0]
[1, 5]
```

列表推导式的一般形式是：

```python
[<map expression> for <name> in <sequence expression> if <filter expression>]
```

为了计算列表推导式，Python 会计算 <sequence expression>，它必须返回一个可迭代的值。 然后，对于按顺序排列的每个元素，元素值绑定到 <name>，if <filter expression>为真，计算`map expression`表达式并把其值被收集到一个列表中

推导式的值是在新的局部框架中计算的，name 的值是未定义的。
在一个循环中给出一个循环的效果(**for语句可以有多个**)：

```python
>>> [ (a, b) for a in range(10, 13) for b in range(2) ] 
[(10, 0), (10, 1), (11, 0), (11, 1), (12, 0), (12, 1)]
```



**内置函数**：

append(x) 将元素x添加到列表尾部中

```python
s = [2, 3]
t = [5, 6]
>>>s.append(4) 
[2, 3, 4]
>>>s.append(t) 
[2, 3, 4, [5, 6]]
```

extend() 将一个列表中的所有元素添加到一个列表中

```python
s = [2, 3]
t = [5, 6]
>>>s.extend(4) 
error:4 is not an iterable(迭代)
>>>s.extend(t)  
[2, 3, 5, 6]
```

pop() 移除并返回最后一个元素

```python
s = [2, 3]
t = [5, 6]
>>>t = s.pop()
3
>>>name1=name.pop(x)#删除并返回name中索引为x的元素

```

remove() 删除与参数相等的第一个元素

```python
s = [6, 2, 4, 8, 4]
>>>s.remove(4)
None
>>>s
[6, 2, 8, 4]
```

insert(x,y)把元素y放到指定索引x的位置上，其后面的元素都后退

```
s=[1,2,3,4,5]
s.insert(3,10)
>>>s
[1,2,3,10,4,5]
```

count(list,x)计算x在list中出现的个数

```python
count(advice，"exam") == advice.count("exam") 
```



### **range**

`range`：表示一个整数范围，它需要两个整数参数：第一个数字和一个超出所需范围内最后一个数字的数字

```python
>>> range(1, 10)  # Includes 1, but not 10
range(1, 10)
```

在range上调用列表构造函数会计算出与range具有相同元素的列表，以便可以轻松检查元素。

```python
>>> list(range(5, 8))
[5, 6, 7]
>>>print(range(0,3))
range(0, 3)
```

如果仅给出一个参数，则它被解释为超出从 0 开始的范围的最后一个值的一个。

```python
>>> list(range(4))
[0, 1, 2, 3]
```

range通常作为 for 标头中的表达式出现，以指定套件应执行的次数：如果套件中未使用名称，则常见约定是在 for 标头中使用单个下划线字符作为名称：

```python
>>> for _ in range(3):
        print('Go Bears!')
Go Bears!
Go Bears!
Go Bears!
```

就解释器而言，这个下划线只是环境中的另一个名称，但在程序员中具有约定俗成的含义，表明该名称不会出现在任何表达式中。



### Strings

对于计算机科学而言，文本值可能比数值更重要。 例如，Python 程序是作为文本编写和存储的。 Python 中文本的基本数据类型称为字符串，对应于构造函数 `str`。

关于如何在 Python 中表示、表达和操作字符串有很多细节。 字符串是丰富抽象的另一个例子，它需要程序员付出大量努力才能掌握。 本节对字符串做个简要介绍。

字符串字面值可以表达任意文本，用单引号或双引号括起来。

```python
>>> 'I am string!'
'I am string!'
>>> "I've got an apostrophe"
"I've got an apostrophe"
>>> '您好'
'您好'
```

我们已经在我们的代码中看到了字符串，如文档字符串、调用`print`以及`assert`语句中的错误消息

字符串的元素本身就是只有一个字符的字符串。 字符是字母表中的任何单个字母、标点符号或其他符号。 与许多其他编程语言不同，Python 没有单独的字符类型。 任何文本都是字符串，表示单个字符的字符串的长度为 1。

多行文字。 字符串不限于一行。 三重引号分隔跨越多行的字符串文字。 我们已经在文档字符串中广泛使用了这种三重引用。

```python
>>> """The Zen of Python
claims, Readability counts.
Read more: import this."""
'The Zen of Python\nclaims, "Readability counts."\nRead more: import this.'
```

在上面的打印结果中，`\n`是一个表示新行的单个元素。 尽管它显示为两个字符，但出于长度和元素选择的目的，它被视为单个字符。

字符串强制： 通过使用对象值作为参数调用` str` 构造函数，可以从 Python 中的任何对象创建字符串。 字符串的这一特性对于从各种类型的对象构造描述性字符串很有用。

````python
str(2)="2"
````

进一步阅读： 在计算机中编码文本是一个复杂的话题。 在本章中，我们将抽象出字符串表示方式的细节。 但是，对于许多应用程序，计算机如何编码字符串的特定细节是必不可少的知识。 Dive Into Python 3 的[字符串章节](https://finderiko.com/python-book)提供了字符编码和 Unicode 的描述。



### **元组**

 -  用小括号将所有元素括起，可括可不括 
 -  相当于其元素不能修改的列表

```python
>>>t=5,7,9==(5,8,7)  
True
>>>print(t1,t)  #print函数总会显示由括号包围的元组
(5,8,7) (5,7,9)

>>>(x,y,z)=(5,6,7)  #创建三个变量并赋值
x=5,y=6,z=7
```



## 2.3.2序列特性



**1.序列的加法与乘法**

模块**operator**中的 **add 函数(+)：**是将两个序列(**同类型的**)串联在一起形成一个新的序列，

`mul`函数(*)：接受一个序列和一个整数 k 来返回由原始序列的 k 次重复组成的序列

```python
>>> [2, 7] + digits * 2
[2, 7, 1, 8, 2, 8, 1, 8, 2, 8]
a="ac"
>>>a=a*2+"b" 
acacb
>>>[]+[]
[]
>>> (1,2)*3+(3,4)
(1, 2, 1, 2, 1, 2, 3, 4)
>>>range(0,5)+range(5,7) #error:range不支持加法和乘法
```



**2.索引：**在序列中索引为-1的元素是序列中最后一个元素

```python
>>>digits[-1] 
8

>>>str[2]
c

>>>list1[3][0] #如果序列的元素还是个序列，则可以嵌套索引
2

>>>range(0, 7)[1]
1
```



 **3.运算符 in 和 not in:** 根据元素是否出现在序列中，其计算结果为 True 或 False。

```python
digits=[1, 8, 2, 8]
>>> 2 in digits

>>> 'here' in "Where's Waldo?"
True

>>>3 in range(0,3)
False
```



**4.切片（切片的结果还是序列）:** 是原始序列的任何连续跨度，由一对整数指定。 与定义range一样，第一个整数表示切片的起始索引，第二个整数表示超出结束索引的一个。

使用方括号， 冒号分隔起始索引和结束索引。任何被省略的边界都被假定为一个极值：0 代表起始索引，序列的长度代表结束索引。

```python
digits=[1, 8, 2, 8,7]
digits[:]==digits
>>>digits[:-1]    #等价于digits[:len(digits)-1]
[1,8,2,8]
digits[2:]==digits[2:len(digits)]
digits[1:2]==digits[1]
>>>digits[1:1]
[]
>>>digits[1:1]+=[1,2,3]
[1, 1, 2, 3, 8, 2, 8, 7]
>>>digits[len(digits):]+=[0,2,5]
[1, 1, 2, 3, 8, 2, 8, 7,0,2,5]
>>>range(0,3)[0:2]
range(0, 2)

digits[::-1] #反转序列
digits[::2]==digits[0:len(digits):2]==[1,2,7]#方括号里的2是步长
>>>digits[4::-1]#从digits[4]开始，步长为-1直到一端结束
[7, 8, 2, 8, 1]
```

枚举 Python 序列抽象的这种附加行为，让我们有机会思考一般有用的数据抽象的构成要素。抽象的丰富程度（即它包含多少行为）会产生影响。对于使用抽象的用户，额外的行为可能会有所帮助。另一方面，使用新数据类型满足丰富抽象的要求可能具有挑战性。丰富抽象的另一个负面后果是用户需要更长的时间来学习。

序列具有丰富的抽象，因为它们在计算中无处不在，以至于学习一些复杂的行为是合理的。一般来说，大多数用户定义的抽象应该尽可能简单。

**进一步阅读:** 切片符号允许各种特殊情况，例如负起始值、结束值和步长。 在 Dive Into Python 3 中名为[切片列表](https://finderiko.com/python-book#slicinglists)的小节中对切片有完整的描述





## 2.3.3序列处理



**1.序列之间的转换**

```python
list( (1, 2, 3) ) == [1, 2, 3]
tuple([1, 2, 3]) == (1, 2, 3)
list(range(2, 10, 2)) == [2, 4, 6, 8]
list("ABCD") = ['A', 'B', 'C', 'D']
str(2)="2"
str(list("ABCD"))="ABCD"
>>>str(range(0,7)) #字符串和range不能直接转换
range(0,7) #字符串

>>>list(zip([1, 2, 5, 3], [9, 2, 6, 3, 10]))
[(1, 9), (2, 2), (5, 6), (3, 3)]
```



**2.迭代：**序列是可迭代的

在许多情况下，我们希望遍历序列的元素并依次为每个元素执行一些计算。 这种模式非常普遍，以至于 Python 有一个额外的控制语句来处理顺序数据：for 语句。

考虑计算一个值在序列中出现的次数的问题。 我们可以实现一个使用 while 循环的函数来计算

```python
>>> def count(s, value):
        """Count the number of occurrences of value in sequence s."""
        total, index = 0, 0
        while index < len(s):
            if s[index] == value:
                total = total + 1
            index = index + 1
        return total
>>> count(digits, 8)
2
```

Python for 语句可以通过直接迭代元素值来简化这个函数体，而不引入名称索引。

```python
>>> def count(s, value):
        """Count the number of occurrences of value in sequence s."""
        total = 0
        for elem in s:
            if elem == value:
                total = total + 1
        return total
>>> count(digits, 8)
2
```

for 语句由单个子句组成，格式为：

```python
for <name> in <expression>:
    <suite>
```

for 语句的执行过程如下:

1. 计算表达式 <expression>，它必须产生一个可迭代的值。
2. 对于该可迭代值中的每个元素值，按顺序：
   1. 将 <name> 绑定到当前帧中的那个值。
   2. 执行 <suite>。

此执行过程引用了可迭代值， 它的元素按其顺序考虑 。 术语“可迭代”的一般定义出现在第 4 章关于迭代器的部分。

此计算过程的一个重要结果是 <name> 将在 for 语句执行后绑定到序列的最后一个元素。 for 循环引入了另一种可以通过语句更新环境的方式。****



3.**序列拆包：** 这种将多个名称绑定到固定长度序列中的多个值的模式称为序列拆包(**不包括字符串**)

程序中的一个常见模式是有一个元素序列，这些元素本身就是序列，但都是固定长度的。 for 语句可以在其标头中包含多个名称，以将每个元素序列“解包”到其各自的元素中。例如，我们可能有一个由两个元素组成的列表。

```python
>>> pairs = [[1, 2], [2, 2], [2, 3], [4, 4]]
```

并希望找到该序列满足条件的对的数量，例如对[1,1]，因为1==1，所以该对满足条件。

```python
>>> same_count = 0
```

下面的for语句有两个名称 x 和 y ，他们绑定到每对中的第一个和第二个元素上。

```python
>>> for x, y in pairs:
        #将pairs中的每个元素解包成两个元素(因为是x，y两个元素)分别于x,y绑定
        if x == y:
            same_count = same_count + 1
>>> same_count
2
>>>a,b,c=[1,2,3] #1
1 2 3
```

序列拆包与我们在将多个名称绑定到多个值的赋值语句中看到的模式相同



**4.聚合**：序列处理中的第三种常见模式是将序列中的所有值聚合为一个值。 内置函数` sum`、`min` 和 `max` 都是聚合函数的示例。

```python
#所有的序列
>>>sum(range(0,6))
 15
>>>len(range(0,6))
6
>>>min(range(0,6))
0
```

 

### 2.3.4序列处理示例

> 用列表推导式来作示例

完美数是一个正整数，它等于它的除数之和。 n 的除数是小于 n 的正整数，它们可以整除 n。 列出 n 的除数可以用列表推导式表示。

```python
>>> def divisors(n):
        return [1] + [x for x in range(2, n) if n % x == 0]
>>> divisors(4)
[1, 2]
>>> divisors(12)
[1, 2, 3, 4, 6]
```

使用`divisors`，我们可以用另一种列表推导式计算从 1 到 1000 的所有完美数。 （1 通常也被认为是一个完全数，但它不符合我们对除数的定义。）

```python
>>> [n for n in range(1, 1000) if sum(divisors(n)) == n]
[6, 28, 496]
```

我们可以用`divisors`的定义来解决另一个问题，在给定面积的情况下，找到具有整数边长的矩形的最小周长. 我们通过` assert area % height == 0 ` 这条语句确保边长是整数。

```python
>>> def width(area, height):
        assert area % height == 0 
        return area // height
    
>>> def perimeter(width, height):
        """求周长"""
        return 2 * width + 2 * height    
```

边长为整数的矩形的高度必须是其面积的除数。 我们可以通过考虑所有高度来计算最小周长。

```python
>>> def minimum_perimeter(area):
        heights = divisors(area)
        perimeters = [perimeter(width(area, h), h) for h in heights]
        return min(perimeters)
>>> area = 80
>>> width(area, 5)
16
>>> perimeter(16, 5)
42
>>> perimeter(10, 8)
36
>>> minimum_perimeter(area)
36
>>> [minimum_perimeter(n) for n in range(1, 10)]
[4, 6, 8, 8, 12, 10, 16, 12, 12
```



**高阶函数**： 我们在序列处理中观察到的常见模式可以使用高阶函数来表达。 首先，可以通过用每个元素调用函数来表达对序列中每个元素的表达式求值。

```python
>>> def apply_to_all(map_fn, s):
        return [map_fn(x) for x in s]
```

可以通过用每个元素调用函数来仅选择满足条件的元素元素。

```python
>>> def keep_if(filter_fn, s):
        return [x for x in s if filter_fn(x)]
```

最后，许多形式的聚合可以表示为重复`reduced`值调用有两个参数的函数，并依次用每个元素来调用。

```python
>>> def reduce(reduce_fn, s, initial):
        reduced = initial
        for x in s:
            reduced = reduce_fn(reduced, x)
        return reduced
```

例如，`reduce` 可用于将序列的所有元素相乘。 用 `mul` 作为` reduce_fn` 和` 1` 来调用`reduce`，

```
>>> reduce(mul, [2, 4, 8], 1)
64
```

我们也可以使用这些高阶函数找到完全数

```python
>>> def divisors_of(n):
        divides_n = lambda x: n % x == 0
        return [1] + keep_if(divides_n, range(2, n))
>>> divisors_of(12)
[1, 2, 3, 4, 6]
>>> from operator import add
>>> def sum_of_divisors(n):
        return reduce(add, divisors_of(n), 0)
>>> def perfect(n):
        return sum_of_divisors(n) == n
>>> keep_if(perfect, range(1, 1000))
[1, 6, 28, 496]
```

**常规名称**： 在计算机科学界，比`apply_to_all` 更常见的名称是` map`，而 比`keep_if` 更常见的名称是 `filter`。 在 Python 中，内置的 `map` 和 `filter` 是这些不返回列表的函数的泛化。 这些函数将在第 4 章中讨论。上面的定义等效于用列表构造函数调用 `map` 和 `filter` 的结果。

```python
>>> apply_to_all = lambda map_fn, s: list(map(map_fn, s))
>>> keep_if = lambda filter_fn, s: list(filter(filter_fn, s))
```

`reduce `函数内置于 Python 标准库的 `functools` 模块中。 在这个版本中，初始参数是可选的。

````python
>>> from functools import reduce
>>> from operator import mul
>>> def product(s):
        return reduce(mul, s)
>>> product([1, 2, 3, 4, 5])
120
````

在 Python 程序中，直接使用列表推导式而不是高阶函数更为常见，但这两种处理序列的方法都被广泛使用。
