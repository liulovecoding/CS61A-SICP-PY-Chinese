# 2.2 数据抽象

> 来源：[2.2   Data Abstraction](http://composingprograms.com/pages/22-data-abstraction.html)

当我们考虑要在我们的程序中表示的世界上的其他事物时，我们发现它们中的大多数都具有复合结构。例如，确定地理位置需要纬度和经度。为了表示位置，我们希望我们的编程语言能够将纬度和经度耦合在一起形成一对，我们的程序可以将其作为一个单元来对其操作的复合数据值。

复合数据的使用使我们能够增加程序的模块化。如果我们可以将地理位置作为一种值来进行操作，那么我们就可以将使计算位置的程序与位置如何表示的细节隔离开来。将组合，表示数据的程序 与 操作数据的程序隔离开来的这种通用技术是一种强大的设计方法，称为数据抽象。数据抽象使程序更易于设计、维护和修改。

数据抽象在特性上类似于函数抽象。当我们创建函数抽象时，函数如何实现的细节被隐藏了，并且特定函数本身可以被任何具有相同行为的函数替换。换句话说，我们可以用抽象将函数的使用方式与函数实现的细节分离。类似地，数据抽象将复合数据值的使用方式与其构建方式的细节隔离开来。

数据抽象的基本思想是构建程序，以便它们对抽象数据进行操作。 也就是说，我们的程序应该以尽可能少的假设来使用数据。 同时，具体的数据表示被定义为程序的独立部分。

程序的这两部分，即对抽象数据进行操作的部分和定义具体表示的部分，通过一组函数连接起来，这些函数根据具体表示来实现抽象数据。 为了说明这种技术，我们将考虑如何设计一组用于操作有理数的函数。



## 2.2.1 示例：有理数的算术

有理数可表示为整数的比值，并且它组成了实数的一个重要子类。类似于`1/3`或者`17/29`的有理数通常可编写为：

```python
<numerator>/<denominator>
```

其中，`<numerator>`和`<denominator>`都是整数值的占位符。实际上，整数相除会产生浮点近似值，从而失去整数的精确精度。

```py
>>> 1/3
0.3333333333333333
>>> 1/3 == 0.333333333333333300000  # Beware of approximations
True
```

 我们可以通过将分子和分母组合在一起来创建有理数的精确表示。

我们从函数抽象中已经知道，在我们实现程序的某些部分之前，我们可以开始高效地编程。 让我们首先假设我们已经有了一种用分子和分母构造有理数的方法。 我们还假设，给定一个有理数，我们有一种得到其分子和分母的值的方法。 让我们进一步假设以下三个函数可用作构造函数和选择器：

- `rational(n, d) `返回分子为 n 分母为 d 的有理数。
- `numer(x)`返回有理数 x 的分子。 
- `denom(x) `返回有理数 x 的分母。 

我们在这里使用了一个强大的程序设计策略：一厢情愿。 我们还没有说有理数是如何表示的，或者函数` numer`、`denom` 和`rational` 应该如何实现。 即便如此，如果我们确实定义了这三个函数，我们就可以使用下面的函数来测试有理数：

```python
>>> def add_rationals(x, y):
        nx, dx = numer(x), denom(x)
        ny, dy = numer(y), denom(y)
        return rational(nx * dy + ny * dx, dx * dy)
    
>>> def mul_rationals(x, y):
        return rational(numer(x) * numer(y), denom(x) * denom(y))
    
>>> def print_rational(x):
        print(numer(x), '/', denom(x))
        
>>> def rationals_are_equal(x, y):
        return numer(x) * denom(y) == numer(y) * denom(x)
```

现在我们拥有了由选择器函数`numer`和`denom`，以及构造器函数`make_rat`定义的有理数操作。但是我们还没有定义这些函数。我们需要以某种方式来将分子和分母粘合为一个单元。

现在我们已经根据选择器函数` numer` 和 `denom` 以及构造函数`rational` 定义了对有理数的操作，但是我们还没有定义这些函数。 我们需要的是某种方式将分子和分母组合成一个复合值。

## 2.2.2 pairs

为了使我们能够实现数据抽象的具体级别，Python 提供了一种称为列表的复合结构，可以通过将表达式放在以逗号分隔的方括号内来构造它。 这样的表达式称为列表字面值。

```python
>>> [10, 20]
[10, 20]
```

可以通过两种方式访问列表的元素。 第一种方法是通过我们熟悉的多重赋值方法，它将列表解包为其元素并将每个元素绑定到不同的名称。

```python
>>> pair = [10, 20]
>>> pair
[10, 20]
>>> x, y = pair
>>> x
10
>>> y
20
```

访问元组元素的第二种方式是通过下标(也叫索引)运算符，也使用方括号表示。

```python
>>> pair[0]
1o
>>> pair[1]
20
```

Python 中的列表的（以及多数其它编程语言中的序列）下标都以 0 开始，也就是说，下标 0 表示第一个元素，下标 1 表示第二个元素，以此类推。我们对这个下标的一种直觉是，下标表示一个元素距离列表开头的偏移值。

与元素选择操作等价的函数叫做`__getitem__`，它也从 0开始选择元素。

```py
>>> from operator import getitem
>>> getitem(pair, 0)
1
>>> getitem(pair, 1)
20
```

只有两个元素列表不是 Python 中表示对的唯一方法。 任何将两个值捆绑在一起的方式都可以被视为一对。 列表是一种常用的方法。 列表也可以包含两个以上的元素，我们将在本章后面进行探讨。

有理数： 我们现在可以将一个有理数表示为两个整数的组合：一个分子和一个分母。

```python
>>> def rational(n, d):
        return [n, d]
>>> def numer(x):
        return x[0]
>>> def denom(x):
        return x[1]
```

结合我们之前定义的算术运算，我们可以使用我们定义的函数来操作有理数。

```python
>>> half = rational(1, 2)
>>> print_rational(half)
1 / 2
>>> third = rational(1, 3)
>>> print_rational(mul_rationals(half, third))
1 / 6
>>> print_rational(add_rationals(third, third))
6 / 9
```

如上例所示，我们的有理数实现并没有将有理数化为最简。 我们可以通过修改`rational` 的实现来弥补这个缺陷。 如果我们有一个函数来计算两个整数的最大公分母，我们可以在构造对之前使用它来将分子和分母化为最简。 与许多有用的工具一样，已经存在于 Python 库中。

```python
>>> from fractions import gcd
>>> def rational(n, d):
        g = gcd(n, d)
        return (n//g, d//g)
```

双斜杠运算符`//`表示整数除法，，它会舍去除法结果的小数部分得到一个整数。由于我们知道`g`能整除`n`和`d`，整数除法正好适用于这里。现在我们确保有理数是最简的

```python
>>> print_rational(add_rationals(third, third))
2 / 3
```

这个修改只通过修改构造器来完成，并没有修改任何实现实际算术运算的函数。



## 2.2.3 抽象界限

在继续介绍复合数据和数据抽象的更多示例之前，让我们思考一些由有理数示例而产生的问题。 我们根据构造函数`rational` 和选择器`numer` 和`denom` 来定义操作。 一般而言，数据抽象的基本思想是确定一组基本操作，根据这些操作来表达对某种值的所有操作，然后仅使用这些操作来操作数据。 通过以这种方式限制操作的使用，在不改变程序行为的情况下更容易改变抽象数据的表示。

对于有理数，程序的不同部分使用不同的操作来处理有理数，如下表所述。



| **Parts of the program that...** | **把有理数作为** | **Using only...**                                            |
| -------------------------------- | ---------------- | ------------------------------------------------------------ |
| 使用有理数进行计算               | 一种类型的值     | `add_rational`,` mul_rational`, `rationals_are_equal`, `print_rational` |
| 创建有理数或实现对有理数的操作   | 分子和分母       | `rational`, `numer`,` denom`                                 |
| 为有理数实现选择器和构造器       | 只有两个元素的列 | 列表值和元素选择                                             |

在上面的每一层中，最后一列中的函数强制执行一个抽象障碍。 这些函数由更高级别调用并使用更低级别的抽象实现。

每当程序的某部分可以使用更高级别的函数而不是使用更低级别的函数时，就会发生抽象障碍违规。 例如，计算有理数平方的函数最好根据 `mul_rational` 实现，它不假设任何关于有理数的实现。

```python
>>> def square_rational(x):
        return mul_rational(x, x)
```

直接引用分子和分母会违反一个抽象障碍。

```python
>>> def square_rational_violating_once(x):
        return rational(numer(x) * numer(x), denom(x) * denom(x))
```

假设有理数表示为二元列表会违反两个抽象障碍。

```python
>>> def square_rational_violating_twice(x):
        return [x[0] * x[0], x[1] * x[1]]
```

抽象障碍使程序更易于维护和修改。 依赖于特定表示的函数越少，想要更改该表示时所需的更改就越少。以上三个函数的实现都是正确的，但只有第一个对未来的变化是健壮的。 即使我们改变了有理数的表示，`square_rational `函数也不需要更改。 相比之下，只要选择器或构造函数的函数签名发生变化，`square_rational_violating_once `就需要更改，而只要有理数的实现发生变化，`square_rational_violating_twice` 就需要更改。



## 2.2.4 数据属性

抽象障碍塑造了我们思考数据的方式。有理数的正确表示不限于任何特定的实现（例如二元列表）；它是由`rational `函数返回的值，可以传递给`numer` 和`denom`。此外，构造函数和选择器之间必须保持适当的关系。也就是说，如果我们用整数 n 和 d 构造一个有理数 x，那么 `numer(x)`/`denom(x)` 应该等于 n/d。

通常，我们可以使用选择器和构造器的集合以及一些行为条件来表达抽象数据。只要满足行为条件（比如上面的除法特性），选择器和构造器就构成了一种数据的正确表示。抽象障碍下面的实现细节可能会改变，但如果行为没有改变，那么数据抽象仍然有效，并且使用此数据抽象编写的任何程序都将保持正确。

这种观点可以广泛应用，包括我们用来实现有理数用的 对 的值、。我们实际上从未过多谈论过什么是一对，只是语言提供了创建和操作具有两个元素的列表的方法。我们需要实现对的行为是将两个值组和在一起并表述为行为条件，

如果一个对 `p` 是由值 `x` 和` y` 构造的，则 `select(p, 0)` 返回 `x`，而 `select(p, 1)` 返回 `y`。
我们实际上不需要用列表来创建对。相反，我们可以实现两个函数` pair` 和 `select` 来满足这个描述，就像一个有两个元素列表一样。

```python
>>> def pair(x, y):
        """Return a function that represents a pair."""
        def get(index):
            if index == 0:
                return x
            elif index == 1:
                return y
        return get
>>> def select(p, i):
        """Return the element at index i of pair p."""
        return p(i)
```

使用这个实现，我们可以创建和操作对：

```python
>>> p = pair(20, 14)
>>> select(p, 0)
20
>>> select(p, 1)
14
```

高阶函数的这种用法与我们对数据应该是什么的直观概念完全不同。 尽管如此，这些函数足以在我们的程序中表示对。 函数足以表示复合数据。

展示对的函数表示的重点不是 Python 实际上以这种方式工作（出于效率原因，列表被更直接地实现），而是它可以以这种方式工作。 函数表示虽然晦涩，但却是表示对的一种完全合适的方式，因为它满足对需要满足的唯一条件。 数据抽象的实践使我们可以轻松地在表示之间切换。



这个偶对的函数表示并不是 Python 实际的工作机制（元组实现得更直接，出于性能因素），但是它可以以这种方式工作。这个函数表示虽然不是很明显，但是是一种足够完美来表示偶对的方式，因为它满足了偶对唯一需要满足的条件。这个例子也表明，将函数当做值来操作的能力，提供给我们表示复合数据的能力。
