1.6 高阶函数

> 来源：[1.6   Higher-Order Functions](http://composingprograms.com/pages/16-higher-order-functions.html)

我们已经看到，函数实际上是描述复合操作的抽象，这些操作不依赖于它们的参数值。在`square`中，

```python
>>> def square(x):
        return x * x
```

我们不会谈论特定数值的平方，而是谈论一个获得任何数值平方的方法。当然，我们可以不定义这个函数来使用它，通过始终编写这样的表达式：

```python
>>> 3 * 3
9
>>> 5 * 5
25
```

并且永远不会显式提及`square`。这种做法对于简单的计算（例如 square）来说已经足够了，但对于更复杂的例子（例如 abs 或 fib）来说就变得很困难了。一般来说，缺少函数定义会使我们处于不利地位，迫使我们只能使用语言提供的操作(在这种情况下为乘法)而不是使用更高级别的操作。我们的程序将能够计算平方，但我们的语言将缺乏表达平方概念的能力。

我们对一个强大的编程语言的要求之一：通过将名称分配给常见模式然后直接根据名称进行工作来构建抽象的能力。函数提供了这种能力。

我们将会在下个例子中看到，有一些常见的编程模式在代码中重复出现，但是使用一些不同函数来实现。

要将某些通用模式表示为命名概念，我们需要构造可以接受其他函数作为参数或将函数作为返回值的函数。 操作函数的函数称为高阶函数。 本节展示了高阶函数如何作为强大的抽象机制，极大地提高我们语言的表达能力。

## 1.6.1 作为参数的函数

考虑下面三个函数，它们都计算总和。第一个，`sum_naturals`，计算截至`n`的自然数的和：

```python
>>> def sum_naturals(n):
        total, k = 0, 1
        while k <= n:
            total, k = total + k, k + 1
        return total
>>> sum_naturals(100)
5050
```

第二个，`sum_cubes`，计算截至`n`的自然数的立方和：

```python
>>> def sum_cubes(n):
        total, k = 0, 1
        while k <= n:
            total, k = total + pow(k, 3), k + 1
        return total
>>> sum_cubes(100)
25502500
```

第三个，计算这个级数中式子的和(称式1)：

![](img/pi_sum.png)

它会慢慢收敛于`pi`。

```python
>>> def pi_sum(n):
        total, k = 0, 1
        while k <= n:
            total, k = total + 8 / (k * (k + 2)), k + 4
        return total
>>> pi_sum(100)
3.121594652591009
```

这三个函数在背后都具有相同模式。它们大部分相同，只是名字、用于计算被加项的`k`的函数，以及提供`k`的下一个值的函数不同。我们可以通过向相同的模板中填充槽位来生成每个函数：

```python
def <name>(n):
    total, k = 0, 1
    while k <= n:
        total, k = total + <term>(k), <next>(k)
    return total
```

这个常见模式的出现是一个强有力的证据，表明有一种有用的抽象正在等待浮出水面。这些函数的每一个都是式子的总和。作为程序的设计者，我们希望我们的语言足够强大，以便我们可以编写一个表达求和概念的函数，而不仅仅是计算特定求和的函数。我们可以在 Python 中使用上面那个模板，并且把槽位变成形式参数来得到该函数。

在下面的示例中，`summation` 将上限 `n` 以及计算第 k 项的函数`term`作为它的两个参数。 我们可以像使用任何函数一样使用 `summation`，它简洁地表达了 `summations`。 花点时间逐步完成此示例，并注意如何将`cube`绑定到本地名称`term`以确保计算`1*1*1 + 2*2*2 + 3*3*3 = 36`得到的结果是正确的。 在这个例子中，不再需要的帧被移除以节省空间。



![1.6.1](D:\git\SICP_Python\img\1.6.1.png)

我们可以把` identity `函数作为参数调用`summation`函数或者使用`sum_naturals` 函数来对自然数求和(结果一致)。

```python
>>> def summation(n, term):
        total, k = 0, 1
        while k <= n:
            total, k = total + term(k), k+1
        return total

>>> def identity(x):
        return x    
    
>>> def sum_naturals(n):
        return summation(n, identity)
    
>>> sum_naturals(10)
55    
```

`summation` 函数也可以直接调用，无需为特定序列定义另一个函数。

```python
>>> summation(10, square)
385
```

我们可以使用`summation`函数来定义 `pi_sum`, 我们在`pi_sum`函数中使用`n`和函数`pi_term`作为参数来调用`summation`函数来计算`1e6`这个级别式1的值。 我们传递参数`1e6`，它是`1 * 10^6 = 1000000`的简写，以生成对 pi (圆周率)的近似值。

```python
>>> def pi_term(x):
        return 8 / ((4*x-3) * (4*x-1))
    
>>> def pi_sum(n):
        return summation(n, pi_term)
    
>>> pi_sum(1e6)
3.141592153589902
```



## 1.6.2 作为一般方法的函数

我们引入用户定义函数作为抽象数值运算模式的机制，从而使它们独立于所涉及的特定数字。对于高阶函数，我们开始看到一种更强大的抽象：一些函数表达了通用的计算方法，独立于它们调用的特定函数。

在概念上函数的意义被扩展了，我们对于如何求解调用表达式的环境模型也优雅地延伸到了高阶函数的情况，无需更改。当用一些实参(用来调用一个函数所用参数的称呼)调用一个用户定义函数时，在新的局部帧中形式参数绑定到这些实参（可能是函数）的值。

考虑下面的例子，我们实现了通用方法` improve`函数并使用它来计算黄金比例。黄金比例，通常称为“phi”，是一个接近 1.6 的数字。

` improve`函数从形参`guess`的值开始。它不断调用`update`函数来使`guess`的值更加靠近“phi”，并且调用`close`来检查当前的`guess`是否“足够接近” "phi"。

```python
>>> def improve(update, close, guess=1):
        while not close(guess):
            guess = update(guess)
        return guess
```

函数`improve` 没有指定正在解决什么问题：这些细节留给作为参数传入的`update`和`close`函数。

黄金比例的特性之一是它可以通过重复将任何正数的倒数与 1 相加来计算“phi”，并且它(正数的倒数+1 )比它的平方小 1。 我们可以将这些特性与`improve`函数一起使用。

```python
>>> def golden_update(guess):
        return 1/guess + 1
>>> def square_close_to_successor(guess):
        return approx_eq(guess * guess, guess + 1)
```

上面，我们引入了对` approx_eq `的调用，如果它的两个参数的值近似相等，则返回 True。 为了实现`approx_eq`，我们可以将两个数字之间差异的绝对值与一个小的容差值进行比较。

```python
>>> def approx_eq(x, y, tolerance=1e-5):
        return abs(x - y) < tolerance
```

使用`golden_update`和`square_close_to_successor`作为参数来调用`improve`会计算出黄金比例的近似值。

```python
>>> improve(golden_update, square_close_to_successor)
1.6180371352785146
```

通过跟踪计算“phi”近似值的过程，我们就可以观察如何计算出“phi”的近似值。首先，用`update`、`close`和`guess`构建`improve`局部帧。在`improve`的函数体中，名称`close`绑定到`square_close_to_successor`上，用`guess`(初始值)调用`close`。跟踪其余的步骤，以查看黄金比例的计算过程

![1.6.2](D:\git\SICP_Python\img\1.6.2.png)

这个扩展后的例子展示了计算机科学中两个重要概念。首先，命名和函数允许我们抽象出大量的复杂性。虽然每个函数定义都是微不足道的，但由我们的计算程序启动的计算过程是非常复杂的。其次，正是由于Python 有一个非常通用的计算程序，小组件才能组合成复杂的程序。了解 解释 程序的过程使我们能够验证和检查我们创建的程序

像通常一样，我们的新的`improve`函数需要测试来检查正确性。黄金比例可以提供这样一个测试，因为它也有一个闭式解，我们可以将它与迭代结果进行比较。

```python
>>> from math import sqrt
>>> phi = 1/2 + sqrt(5)/2
>>> def improve_test():
        approx_phi = improve(golden_update, square_close_to_successor)
        assert approx_eq(phi, approx_phi), 'phi differs from its approximation'
>>> improve_test()
```

对于这个测试，没有消息就是好消息：improve_test 在它的 assert 语句执行成功后返回 None。

## 1.6.3 定义函数 III：嵌套定义

上面的例子演示了将函数作为参数传递的能力如何提高了编程语言的表现力。每个通用的概念或方程都映射到自己的小型函数上，这中方法的一个负面后果是全局帧会被小型函数弄乱,同一个环境中的函数的名称必须都是唯一的。另一个问题是我们受到特定函数签名的限制：`improve `的`update`参数必须只接受一个参数。Python 中，嵌套函数定义解决了这些问题，但需要我们丰富我们的环境模型。

让我们考虑一个新问题：计算一个数的平方根。重复调用下面的`sqrt_update`函数会得到一个靠近`x`平方根的值：

```python
>>> def average(x, y):
        return (x + y)/2
>>> def sqrt_update(guess, x):
        return average(guess, x/guess)
```

这个带有两个参数的`sqrt_update`函数和`improve`不兼容(问题1)，`sqrt_update`函数只提供一次更新(问题2)。而我们真正关心的是通过重复调用`sqrt_update`函数来得到一个在误差范围内靠近`x`平方根的值。 这两个问题的解决方案是在函数中定义函数

```python
>>> def sqrt(a):
        def sqrt_update(x):
            return average(x, a/x)
        def sqrt_close(x):
            return approx_eq(x * x, a)
        return improve(sqrt_update, sqrt_close)
```

就像局部赋值一样，局部的`def`语句仅仅影响当前的局部帧。`sqrt`函数中`def`语句仅在调用`sqrt`时才会计算。当调用`sqrt`会创建一个环境，`sqrt`函数中定义的函数就在这个环境中

**词法作用域。**局部定义的函数也可以访问它所在的作用域（即在作用域定义了这些函数)的名称绑定。这个例子中，`sqrt_update`引用了名称`x`，它是外层函数`sqrt`的一个形参。这种在嵌套函数中共享名称的规则叫做词法作用域。严格来说，内部函数能够访问定义它们的环境中（而不是调用所在位置）的名称。

我们需要对我们环境模型进行两个扩展以启用词法作用域。

1.  每个用户定义的函数都有一个父环境：定义它的环境。
2.  当调用用户定义的函数时，它的局部帧会被扩展以能够访问它的父环境的名称。

回到`square`，所有函数都在全局环境中定义，所以他们都有相同的父环境：全局环境。相比之下，当 Python 执行函数` sqrt` 内部的两个def语句时，它会创建两个与本地环境(指python为`sqrt`函数创造的环境)相关联的函数。在

```python
>>> sqrt(256)
16.0
```

的调用中，环境首先为 `sqrt`函数创建一个本地帧，并计算` sqrt_update` 和 `sqrt_close` 函数的 def 语句。

![1.6.4](D:\git\SICP_Python\img\1.6.4.png)

每个函数都有一个新的注释，我们将从现在起将其包含在环境图中，即*parent*注释（指明一个函数的父环境是谁）。函数的父环境是定义该函数的环境的第一帧。没有*parent*注释的函数是在全局环境中定义的。当调用用户定义的函数时，会创建的一个帧，该帧与该函数具有相同的父环境

随后，定义`sqrt_update`和`sqrt_close`函数，并将这两个函数名作为参数调用`improve`函数。在`improve`的函数体中，我们把`guess`作为参数来调用 `update` 函数（`update`绑定到 `sqrt_update`,`x`绑定到`guess`）。最后调用 `sqrt_update`函数并创建了一个仅包含 `x` 的本地帧的环境

![1.6.5](D:\git\SICP_Python\img\1.6.5.png)

此计算过程中最关键的部分是将`sqrt_update`函数的父环境作为调用`sqrt_update`创建的环境的父环境。创建的这个环境也用`[parent=f1]`注释。

**扩展环境**：一个环境可以由任意长的帧组成，它总是以全局帧结束。在此 `sqrt`示例之前，环境最多有两个帧：局部帧和全局帧。通过调用在其他函数中定义的函数，通过嵌套的`def`语句，我们可以创建更长的链。调用`sqrt_update`的环境由三个帧组成：本地 `sqrt_update`帧、定义了`sqrt_update`的`sqrt`帧（标记为`f1`）和全局帧。

在体内的返回表达式`sqrt_update`可以解析为一个值 `一`按照此链的帧。查找名称会找到当前环境中绑定到该名称的第一个值。Python 首先在`sqrt_update`框架中检查——不存在`a`。Python 在父框架`f1 中`检查下一个，并找到`a`到 256的绑定。

所以我们意识到了词法作用域的两个关键优势。

+ 局部函数的名称并不影响定义所在函数外部的名称，因为局部函数的名称绑定到了定义处的当前局部环境中，而不是全局环境。
+ 局部函数可以访问外层函数的环境。这是因为局部函数的函数体的求值环境扩展于定义处的求值环境。

`sqrt_update`函数自带了一些数据：也就是在定义处环境中的数据。因为它以这种方式封装信息，局部定义的函数通常叫做闭包。



## 1.6.4 作为返回值的函数

我们的程序可以通过创建返回值是它们本身的函数，获得更高的表现力。带有词法作用域的编程语言的一个重要特性就是，局部定义函数在它们返回时仍旧持有所关联的环境。下面的例子展示了这一特性的作用。

在定义了许多简单函数之后，`composition`是包含在我们的编程语言中的自然组合法。也就是说，提供两个函数`f(x)`和`g(x)`，我们可能希望定义`h(x) = f(g(x))`。我们可以使用现有工具来定义复合函数：

```python
>>> def compose1(f, g):
        def h(x):
            return f(g(x))
        return h
```

本示例的环境图显示了名称`f`和`g` 是如何正确解析的，即使存在名称冲突也是如此。

![1.6.6](D:\git\SICP_Python\img\1.6.6.png)

`compose1`中的`1`表明复合函数和返回值都只接受一个参数。这种命名惯例并不由解释器强制，`1`只是函数名称的一部分。

这里，我们开始观察我们在计算的复杂模型中投入的回报。我们的环境模型不需要任何修改就能支持以这种方式返回函数的能力。



## 1.6.5 示例：牛顿法

最后的扩展示例展示了函数值、局部定义和 Lambda 表达式如何一起工作来简明地表达通常的概念。

牛顿法是一个传统的迭代方法，用于寻找使数学函数返回值为零的参数。这些值叫做一元数学函数的根。寻找一个函数的根通常等价于求解一个相关的数学方程。

+ 16 的平方根是满足`square(x) - 16 = 0`的`x`值。
+ 以 2 为底 32 的对数（例如 2 与某个指数的幂为 32）是满足`pow(2, x) - 32 = 0`的`x`值。

所以，求根的通用方法会向我们提供算法来计算平方根和对数。而且，我们想要计算根的等式只包含简单操作：乘法和乘方。

在我们继续之前有个注解：我们知道如何计算平方根和对数，这个事实很容易当做自然的事情。并不只是 Python，你的手机和计算机，可能甚至你的手表都可以为你做这件事。但是，学习计算机科学的一部分是弄懂这些数如何计算，而且，这里展示的通用方法可以用于求解大量方程，而不仅仅是内建于 Python 的东西。

在开始理解牛顿法之前，我们可以开始编程了。这就是函数抽象的威力。我们简单地将之前的语句翻译成代码：

```py
>>> def square_root(a):
        return find_root(lambda x: square(x) - a)
>>> def logarithm(a, base=2):
        return find_root(lambda x: pow(base, x) - a)
```

当然，在我们定义`find_root`之前，现在还不能调用任何函数，所以我们需要理解牛顿法如何工作。

牛顿法也是一个迭代改进算法：它会改进任何可导函数的根的推测值。要注意我们感兴趣的两个函数都是平滑的。对于

+ `f(x) = square(x) - 16`（细线）
+ `f(x) = pow(2, x) - 32`（粗线）

在二维平面上画出`x`对`f(x)`的图像，它展示了两个函数都产生了光滑的曲线，它们在某个点穿过了 0。

![](img/curves.png)

由于它们是光滑的（可导的），这些曲线可以通过任何点上的直线来近似。牛顿法根据这些线性的近似值来寻找函数的根。

想象经过点`(x, f(x))`的一条直线，它与函数`f(x)`的曲线在这一点的斜率相同。这样的直线叫做切线，它的斜率叫做`f`在`x`上的导数。

这条直线的斜率是函数值改变量与函数参数改变量的比值。所以，按照`f(x)`除以这个斜率来平移`x`，就会得到切线到达 0 时的`x`值。

![](img/newton.png)

我们的牛顿更新操作表达了跟随这条切线到零的计算过程。我们通过在非常小的区间上计算函数斜率来近似得到函数的导数。

```py
>>> def approx_derivative(f, x, delta=1e-5):
        df = f(x + delta) - f(x)
        return df/delta
>>> def newton_update(f):
        def update(x):
            return x - f(x) / approx_derivative(f, x)
        return update
```

最后，我们可以定义基于`newton_update`（我们的迭代改进算法）的`find_root`函数，以及一个测试来观察`f(x)`是否接近于 0。我们提供了一个较大的初始推测值来提升`logarithm`的性能。

```py
>>> def find_root(f, initial_guess=10):
        def test(x):
            return approx_eq(f(x), 0)
        return iter_improve(newton_update(f), test, initial_guess)
>>> square_root(16)
4.000000000026422
>>> logarithm(32, 2)
5.000000094858201
```

当你实验牛顿法时，要注意它不总是收敛的。`iter_improve`的初始推测值必须足够接近于根，而且函数必须满足各种条件。虽然具有这些缺陷，牛顿法是一个用于解决微分方程的强大的通用计算方法。实际上，非常快速的对数算法和大整数除法也采用这个技巧的变体。

## 1.6.6 Lambda 表达式

目前为止，每次我们打算定义新的函数时，我们都会给它一个名称。但是对于其它类型的表达式，我们不需要将一个间接产物关联到名称上。也就是说，我们可以计算`a*b + c*d`，而不需要给子表达式`a*b`或`c*d`，或者整个表达式来命名。Python 中，我们可以使用 Lambda 表达式凭空创建函数，它会求值为匿名函数。Lambda 表达式是函数体具有单个返回表达式的函数，不允许出现赋值和控制语句。

Lambda 表达式十分受限：它们仅仅可用于简单的单行函数，求解和返回一个表达式。在它们适用的特殊情形中，Lambda 表达式具有强大的表现力。

```py
>>> def compose1(f,g):
        return lambda x: f(g(x))
```

我们可以通过构造相应的英文语句来理解 Lambda 表达式：

```py
     lambda            x            :          f(g(x))
"A function that    takes x    and returns     f(g(x))"
```

一些程序员发现使用 Lambda 表达式作为匿名函数非常简短和直接。但是，复合的 Lambda 表达式非常难以辨认，尽管它们很简洁。下面的定义是是正确的，但是许多程序员不能很快地理解它：

```py
>>> compose1 = lambda f,g: lambda x: f(g(x))
```

通常，Python 的代码风格倾向于显式的`def`语句而不是 Lambda 表达式，但是允许它们在简单函数作为参数或返回值的情况下使用。

这种风格规范不是准则，你可以想怎么写就怎么写，但是，在你编写程序时，要考虑某一天可能会阅读你的程序的人们。如果你可以让你的程序更易于理解，你就帮了人们一个忙。

Lambda 的术语是一个历史的偶然结果，来源于手写的数学符号和早期打字系统限制的不兼容。

> 使用 lambda 来引入过程或函数看起来是不正当的。这个符号要追溯到 Alonzo Church，他在 20 世纪 30 年代开始使用“帽子”符号；他把平方函数记为`ŷ . y × y`。但是失败的打字员将这个帽子移到了参数左边，并且把它改成了大写的 lambda：`Λy . y × y`；之后大写的 lambda 就变成了小写，现在我们就会在数学书里看到`λy . y × y`，以及在 Lisp 里看到`(lambda (y) (* y y))`。

> -- Peter Norvig (norvig.com/lispy2.html)

尽管它的词源不同寻常，Lambda 表达式和函数调用相应的形式语言，以及 Lambda 演算都成为了计算机科学概念的基础，并在 Python 编程社区广泛传播。当我们学习解释器的设计时，我们将会在第三章中重新碰到这个话题。

## 1.6.7 抽象和一等函数

这一节的开始，我们以观察用户定义函数作为关键的抽象技巧，因为它们让我们能够将计算的通用方法表达为编程语言中的显式元素。现在我们已经看到了高阶函数如何让我们操作这些通用方法来进一步创建抽象。

作为程序员，我们应该留意识别程序中低级抽象的机会，在它们之上构建，并泛化它们来创建更加强大的抽象。这并不是说，一个人应该总是尽可能以最抽象的方式来编程；专家级程序员知道如何选择合适于他们任务的抽象级别。但是能够基于这些抽象来思考，以便我们在新的上下文中能使用它们十分重要。高阶函数的重要性是，它允许我们更加明显地将这些抽象表达为编程语言中的元素，使它们能够处理其它的计算元素。

通常，编程语言会限制操作计算元素的途径。带有最少限制的元素被称为具有一等地位。一些一等元素的“权利和特权”是：

1.  它们可以绑定到名称。
2.  它们可以作为参数向函数传递。
3.  它们可以作为函数的返回值返回。
4.  它们可以包含在数据结构中。

Python 总是给予函数一等地位，所产生的表现力的收益是巨大的。另一方面，控制结构不能做到：你不能像使用`sum`那样将`if`传给一个函数。

## 1.6.8 函数装饰器

Python 提供了特殊的语法，将高阶函数用作执行`def`语句的一部分，叫做装饰器。


```py
>>> def trace1(fn):
        def wrapped(x):
            print('-> ', fn, '(', x, ')')
            return fn(x)
        return wrapped
>>> @trace1
    def triple(x):
        return 3 * x
>>> triple(12)
->  <function triple at 0x102a39848> ( 12 )
36
```

这个例子中，定义了高阶函数`trace1`，它返回一个函数，这个函数在调用它的参数之前执行`print`语句来输出参数。`triple`的`def`语句拥有一个注解，`@trace1`，它会影响`def`的执行规则。像通常一样，函数`triple`被创建了，但是，`triple`的名称并没有绑定到这个函数上，而是绑定到了在新定义的函数`triple`上调用`trace1`的返回函数值上。在代码中，这个装饰器等价于：

```py
>>> def triple(x):
        return 3 * x
>>> triple = trace1(triple)
```

**附加部分：**实际规则是，装饰器符号`@`可以放在表达式前面（`@trace1`仅仅是一个简单的表达式，由单一名称组成）。任何产生合适的值的表达式都可以。例如，使用合适的值，你可以定义装饰器`check_range`，使用`@check_range(1, 10)`来装饰函数定义，这会检查函数的结果来确保它们是 1 到 10 的整数。调用`check_range(1,10)`会返回一个函数，之后它会用在新定义的函数上，在新定义的函数绑定到`def`语句中的名称之前。感兴趣的同学可以阅读 Ariel Ortiz 编写的[一篇装饰器的简短教程](http://programmingbits.pythonblogs.com/27_programmingbits/archive/50_function_decorators.html)来了解更多的例子。
