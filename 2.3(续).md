## 树

我们使用列表作为其他列表元素的能力为我们的编程语言提供了一种新的组合方式。 这种能力称为数据类型的闭包特性。 一般来说，如果组合的结果可以使用相同的方法组合，则组合数据值的方法具有封闭性。 封闭是任何组合方式中的核心，因为它允许我们创建层次结构——由部分组成的结构，这些结构本身又由部分组成，等等。

我们使用盒指针将环境图中的列表可视化。 列表被描述为包含列表元素的相邻框。 诸如数字、字符串、布尔值和 None 之类的基本值出现在元素框中。 复合值，例如函数值和其他列表，由箭头指示。

![2.3.1](D:\git\SICP_Python\img\2.3.1.png)

在列表中嵌套列表会带来复杂性。 树是一种基本的数据抽象，它对分层值的结构和操作方式施加了规律性。

一棵树有一个根标签和一系列分支。 一棵树的每一根树枝都是一棵树。 没有树枝的树叫做叶子。 包含在树中的任何树都称为该树的子树（例如分支的分支）。 树的每个子树的根称为该树中的节点。

树的数据抽象由构造函数树和选择器标签和分支组成。 我们从一个简化版本开始。

```python
>>> def tree(root_label, branches=[]):
        for branch in branches:
            assert is_tree(branch), 'branches must be trees'
        return [root_label] + list(branches)
    
>>> def label(tree):
        return tree[0]
>>> def branches(tree):
        return tree[1:]
```

一棵树只有当它有一个根标签并且所有的树枝也是树时才是正确的。函数 `is_tree` 用于`tree`函数中以验证树的所有分支是否格式正确。

```python
>>> def is_tree(tree):
        if type(tree) != list or len(tree) < 1:
            return False
        for branch in branches(tree):
            if not is_tree(branch):
                return False
        return True
```

 函数`is_leaf`检查树是否有分支。

```python
>>> def is_leaf(tree):
        return not branches(tree)
```

树可以由嵌套表达式构造。 下面的树 t 有根标签 3 和两个分支。

```python
>>> t = tree( 3, [ tree(1), tree( 2, [ tree(1), tree(1) ] ) ] )
>>> t
[3, [1], [ 2, [1], [1] ] ]
>>> label(t)
3
>>> branches(t)
[ [1], [ 2, [1], [1] ] ]
>>> label(branches(t)[1])
2
>>> is_leaf(t)
False
>>> is_leaf(branches(t)[0])
True
```

树递归函数可用于构造树。 例如，第 n 个斐波那契树具有第 n 个斐波那契数的根标签，并且对于 n > 1，两个分支也是斐波那契树。 Fibonacci 树说明了 Fibonacci 数的树递归计算。

```python
>>> def fib_tree(n):
        if n == 0 or n == 1:
            return tree(n)
        else:
            left, right = fib_tree(n-2), fib_tree(n-1)
            fib_n = label(left) + label(right)
            return tree(fib_n, [left, right])
        
>>> fib_tree(5)
[ 5, [ 2, [1], [ 1, [0], [1] ] ], [ 3, [ 1, [0], [1]], [ 2, [1], [1, [0], [1] ] ] ] ]
```

树递归函数也用于处理树。 例如，`count_leaves` 函数计算一棵树的叶子。

```python
>>> def count_leaves(tree):
      if is_leaf(tree):
          return 1
      else:
          branch_counts = [count_leaves(b) for b in branches(tree)]
          return sum(branch_counts)
        
>>> count_leaves(fib_tree(5))
8
```

分区树： 树也可用于表示整数的分区。使用m来划分n的分区树是一个二叉（两个分支）树，表示在计算过程中所采取的选择。 在非叶分区树中：

- 左（索引 0）分支是 使用至少用了一个 m 来划分 n 方法的集合，
- 右（索引 1）分支是 没有用到一个m来划分n的方法的集合，
- 根标签是 m。

分区树上的叶子标签表示从树的根到叶子的路径是否代表一种对n划分的方法。

```python
>>> def partition_tree(n, m):
        """Return a partition tree of n using parts of up to m."""
        if n == 0:
            return tree(True)
        elif n < 0 or m == 0:
            return tree(False)
        else:
            left = partition_tree(n-m, m)
            right = partition_tree(n, m-1)
            return tree(m, [left, right])
        
>>> partition_tree(2, 2)
[ 2, [True], [ 1, [ 1, [True], [False] ], [False] ] ]
```

打印分区树的分区是另一个遍历树的树递归过程，将每个分区构造为一个列表。 当达到真正的叶子时，就会打印分区

```python
>>> def print_parts(tree, partition=[]):
        if is_leaf(tree):
            if label(tree):
                print(' + '.join(partition))
        else:
            left, right = branches(tree)
            m = str(label(tree))
            print_parts(left, partition + [m])
            print_parts(right, partition)
            
>>> print_parts(partition_tree(6, 4))
4 + 2
4 + 1 + 1
3 + 3
3 + 2 + 1
3 + 1 + 1 + 1
2 + 2 + 2
2 + 2 + 1 + 1
2 + 1 + 1 + 1 + 1
1 + 1 + 1 + 1 + 1 + 1
```

切片也可用于树枝。 例如，我们可能想要限制树中的分支数量。 二叉树要么是一片叶子，要么是最多两棵二叉树组成的序列。 一种称为二值化的常见树变换通过将相邻分支组合在一起来从原始树计算二叉树。

```python
>>> def right_binarize(tree):
        """Construct a right-branching binary tree."""
        if is_leaf(tree):
            return tree
        if len(tree) > 2:
            tree = [tree[0], tree[1:]]
        return [right_binarize(b) for b in tree]
>>> right_binarize([1, 2, 3, 4, 5, 6, 7])
[ 1, [ 2, [ 3, [ 4, [ 5, [6, 7] ] ] ] ] ]
```





## 2.3.2 链表

到目前为止，我们只使用基本类型来表示序列。 但是，我们还可以开发未内置于 Python 中的序列表示。 由嵌套对构造的序列的一种常见表示是链表。 下面的环境图说明了包含 包含 1、2、3 和 4 的四元素序列的链表表示。

![2.3.2](D:\git\SICP_Python\img\2.3.2.png)

链表是一个对：包含第两个元素，第二个元素是链表。“empty”表示空链表

> 第一个元素在这图中是基本值

链表具有递归结构：其第二个元素是链表或空链表。 我们可以定义一个抽象的数据表示来验证、构造和选择链表的组件。

```python
>>> empty = 'empty'
>>> def is_link(s):
        """s is a linked list if it is empty or a (first, rest) pair."""
        return s == empty or (len(s) == 2 and is_link(s[1]))
    
>>> def link(first, rest):
        """Construct a linked list from its first element and the rest."""
        assert is_link(rest), "rest must be a linked list."
        return [first, rest]
    
>>> def first(s):
        """Return the first element of a linked list s."""
        assert is_link(s), "first only applies to linked lists."
        assert s != empty, "empty linked list has no first element."
        return s[0]
    
>>> def rest(s):
        """Return the rest of the elements of a linked list s."""
        assert is_link(s), "rest only applies to linked lists."
        assert s != empty, "empty linked list has no rest."
        return s[1]
```

上面，`link` 是一个构造函数，`first` 和 `rest` 是链表的选择器。

- 如果链表 s 是由第一个元素 f 和链表 r 构造的，则 first(s) 返回 f，rest(s) 返回 r。

我们可以使用构造函数和选择器来操作链表。

```python
>>> four = link(1, link(2, link(3, link(4, empty))))
>>> first(four)
1
>>> rest(four)
[ 2, [ 3, [4, 'empty'] ] ]
```

我们使用对（有两个元素的列表）来实现这种抽象数据。 值得注意的是，我们也可以使用函数来实现对，并且我们可以使用对来实现链表，因此我们能只使用函数来实现链表。

链表可以按顺序存储值的序列，但是我们还没有证明它满足序列抽象。 使用我们定义的抽象数据表示，我们可以实现表明其是序列的两种行为：长度和元素选择。

```python
>>> def len_link(s):
        """Return the length of linked list s."""
        length = 0
        while s != empty:
            s, length = rest(s), length + 1
        return length
    
>>> def getitem_link(s, i):
        """Return the element at index i of linked list s."""
        while i > 0:
            s, i = rest(s), i - 1
        return first(s)
```

现在，我们可以使用这些函数将链表作为一个序列进行操作。 （我们还不能使用内置函数` len` 、元素选择或 for 语句，但我们很快就会使用。）

```python
>>> len_link(four)
4
>>> getitem_link(four, 1)
2
```

下面的一系列环境图说明了 `getitem_link` 在链表中找到索引 为1 的元素 2 的这个过程。 下面，我们用 Python 基本语法来定义链表`four`以简化图表。 此实现选择违反了抽象障碍，但允许我们更轻松地检查此示例的计算过程。

![2.3.3](D:\git\SICP_Python\img\2.3.3.png)

首先，调用函数` getitem_link`，创建一个局部框架。

![2.3.4](D:\git\SICP_Python\img\2.3.4.png)

while 头中的表达式计算结果为真，这会导致 while 套件中的赋值语句被执行。 函数` rest `返回以 2 开头的子列表,记为`list1`。

![1.6.5](D:\git\SICP_Python\img\1.6.5.png)

接下来，将更新本地名称 s 以引用`list1`。 然后计算 while 头表达式得到一个假值，因此 Python 计算 `getitem_link`函数 的return 语句中的表达式。

![2.3.6](D:\git\SICP_Python\img\2.3.6.png)

这个最终的环境图显示了调用 `first` 的局部帧，它包含绑定到同一子列表的名称。用2调用函数`first`并返回2，然后` getitem_link` 返回2。

此示例演示了一种使用链表的常见计算模式，其中迭代操作中的每个步骤都对原始列表的越来越短的后缀进行操作。这种查找链表长度和元素的增量处理确实需要一些时间来计算。 Python 内置的序列类型以不同的方式实现，在计算序列的长度或检索其元素方面没有很大的成本。该表示的细节超出了本文的范围。

**递归操作**：` len_link` 和 `getitem_link` 都是迭代操作。他们剥离嵌套对的每一层，直到到达列表的末尾（在 `len_link `中）或所需的元素（在 `getitem_link `中）。我们还可以使用递归实现长度和元素选择。

```python
>>> def len_link_recursive(s):
        """Return the length of a linked list s."""
        if s == empty:
            return 0
        return 1 + len_link_recursive( rest(s) )
    
>>> def getitem_link_recursive(s, i):
        """Return the element at index i of linked list s."""
        if i == 0:
            return first(s)
        return getitem_link_recursive( rest(s), i - 1 )
    
>>> len_link_recursive(four)
4
>>> getitem_link_recursive(four, 1)
2
```

这些递归实现沿着对链，直到到达列表末尾（在 `len_link_recursive `中）或到达所需元素（在 `getitem_link_recursive` 中）。

递归对于转换和组合链表也很有用。

```python
>>> def extend_link(s, t):
        """Return a list with the elements of s followed by those of t."""
        assert is_link(s) and is_link(t)
        if s == empty:
            return t
        else:
            return link(first(s), extend_link(rest(s), t))
        
>>> extend_link(four, four)
[ 1, [ 2, [ 3, [ 4, [ 1, [ 2, [ 3, [ 4, 'empty'] ] ] ]  ] ] ] ]
>>> def apply_to_all_link(f, s):
        """Apply f to each element of s."""
        assert is_link(s)
        if s == empty:
            return s
        else:
            return link( f( first(s)), apply_to_all_link(f, rest(s) ) )
        
>>> apply_to_all_link(lambda x: x*x, four)
[1, [4, [9, [16, 'empty']]]]

>>> def keep_if_link(f, s):
        """Return a list with elements of s for which f(e) is true."""
        assert is_link(s)
        if s == empty:
            return s
        else:
            kept = keep_if_link(f, rest(s))
            if f(first(s)):
                return link(first(s), kept)
            else:
                return kept
            
>>> keep_if_link(lambda x: x%2 == 0, four)
[2, [4, 'empty']]

>>> def join_link(s, separator):
        """Return a string of all elements in s separated by separator."""
        if s == empty:
            return ""
        elif rest(s) == empty:
            return str(first(s))
        else:
            return str(first(s)) + separator + join_link(rest(s), separator)
        
>>> join_link(four, ", ")
'1, 2, 3, 4'
```

**递归构造**：链表在增量构建序列时特别有用，这种情况经常出现在递归计算中。

第 1 章中的 `count_partitions` 函数通过树递归计算用 m 来划分整数 n 的方法的数量。 对于序列，我们还可以使用类似的过程来显式枚举这些分区。

我们对问题进行与计数时相同的递归分析：用 m 来划分整数 n 涉及

- 用 m 对 n-m 进行分区
- 用 m-1 整数对 n 进行分区。

对于基本情况，我们发现 0 有一个空分区，而对负整数进行分区或使用小于 1 的部分是不可能的。

```python
>>> def partitions(n, m):
        """Return a linked list of partitions of n using parts of up to m.
        Each partition is represented as a linked list.
        """
        if n == 0:
            return link(empty, empty) # A list containing the empty partition
        elif n < 0 or m == 0:
            return empty
        else:
            using_m = partitions(n-m, m)
            with_m = apply_to_all_link(lambda s: link(m, s), using_m)
            without_m = partitions(n, m-1)
            return extend_link(with_m, without_m)
```

在递归情况下，我们构造两个分区子列表。第一个使用 m，因此我们将 m 添加到结果 的结果是高度嵌套的：一个链表的链表，每个链表都表示为嵌套对，即列表值。使用带有分隔符的` join_link`，我们可以以人类可读的方式显示分区。

```python
>>> def print_partitions(n, m):
        lists = partitions(n, m)
        strings = apply_to_all_link(lambda s: join_link(s, " + "), lists)
        print(join_link(strings, "\n"))
        
>>> print_partitions(6, 4)
4 + 2
4 + 1 + 1
3 + 3
3 + 2 + 1
3 + 1 + 1 + 1
2 + 2 + 2
2 + 2 + 1 + 1
2 + 1 + 1 + 1 + 1
1 + 1 + 1 + 1 + 1 + 1
```

